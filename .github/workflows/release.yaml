name: Release

on:
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  REPO_NAME: ${{ github.repository }}
  CHART_NAME: blackstart
  RELEASE_VERSION: ${{ github.event.release.tag_name }}

jobs:
  ko-build-publish:
    name: Publish Container Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Setup ko
        uses: ko-build/setup-ko@v0.8

      - name: Install crane
        run: |
          # Install crane for digest resolution
          VERSION=$(curl -s "https://api.github.com/repos/google/go-containerregistry/releases/latest" | jq -r '.tag_name')
          go install github.com/google/go-containerregistry/cmd/crane@${VERSION}

      - name: Prepare version tag
        id: version
        run: |
          # Strip leading 'v' from tag for container image tag
          VERSION="${RELEASE_VERSION#v}"
          echo "tag=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Tag: ${VERSION}"

      - name: Build & publish image with ko (multi-arch)
        id: ko
        env:
          KO_DOCKER_REPO: ${{ env.REGISTRY }}/${{ env.REPO_NAME }}
          VERSION: ${{ steps.version.outputs.tag }}
        run: |
          # --bare => don't include the import path in the image name
          # --tags => apply your git tag (without 'v' prefix)
          # --platform=all uses KO_DEFAULTPLATFORMS
          IMAGE_REF=$(ko build --bare \
            --platform=all \
            --tags "${{ steps.version.outputs.tag }}" \
            ./cmd/blackstart)
          echo "image_ref=${IMAGE_REF}" >> "$GITHUB_OUTPUT"

      - name: Resolve image digest
        id: digest
        run: |
          # Resolve the manifest-list digest for signing/attestation
          # IMAGE_REF already contains the full reference with tag
          DIGEST=$(crane digest "${{ steps.ko.outputs.image_ref }}")
          echo "digest=${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "full_ref=${{ env.REGISTRY }}/${{ env.REPO_NAME }}@${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "Image digest: ${DIGEST}"

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.10.1

      - name: Sign image with Cosign (keyless via GitHub OIDC)
        run: cosign sign --yes "${{ steps.digest.outputs.full_ref }}"

      - name: Attest build provenance
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.REPO_NAME }}
          subject-digest: ${{ steps.digest.outputs.digest }}
          push-to-registry: true

      - name: Show published artifact
        run: |
          echo "Published:  ${{ steps.ko.outputs.image_ref }}:${{ steps.version.outputs.tag }}"
          echo "Digest:     ${{ steps.digest.outputs.digest }}"

  check-if-latest:
    name: Check if Latest Release
    if: github.event.release.prerelease == false
    runs-on: ubuntu-latest
    outputs:
      is_latest: ${{ steps.check.outputs.is_latest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Check if tag matches main branch
        id: check
        run: |
          TAG_COMMIT=$(git rev-list -n 1 ${{ github.event.release.tag_name }})
          MAIN_COMMIT=$(git rev-list -n 1 origin/main)

          echo "Tag commit: ${TAG_COMMIT}"
          echo "Main commit: ${MAIN_COMMIT}"

          if [[ "${TAG_COMMIT}" == "${MAIN_COMMIT}" ]]; then
            echo "is_latest=true" >> $GITHUB_OUTPUT
          else
            echo "is_latest=false" >> $GITHUB_OUTPUT
          fi

  helm-build-publish:
    name: Publish Helm Chart
    runs-on: ubuntu-latest
    needs:
      - check-if-latest
    if: needs.check-if-latest.outputs.is_latest == 'true'
    permissions:
      contents: write
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name }}

      - name: Setup Helm
        run: |
          make helm
          helm version

      - name: Prepare version tag
        id: version
        run: |
          # Strip leading 'v' from tag for container image tag
          VERSION="${RELEASE_VERSION#v}"
          echo "tag=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Tag: ${VERSION}"

      - name: Update Chart.yaml with release version
        run: |
          # Update Chart.yaml with release version (without 'v' prefix)
          sed -i "s/^version:.*/version: \"${{ steps.version.outputs.tag }}\"/" charts/${CHART_NAME}/Chart.yaml
          sed -i "s/^appVersion:.*/appVersion: \"${{ steps.version.outputs.tag }}\"/" charts/${CHART_NAME}/Chart.yaml

          echo "Updated Chart.yaml:"
          grep -E "^(version|appVersion):" charts/${CHART_NAME}/Chart.yaml

      - name: Package Helm chart
        id: package
        run: |
          # Package the chart
          mkdir -p .build-packages
          helm package charts/${CHART_NAME} --destination .build-packages --version "${{ steps.version.outputs.tag }}"

          CHART_FILE="${CHART_NAME}-${{ steps.version.outputs.tag }}.tgz"
          echo "chart_file=${CHART_FILE}" >> "$GITHUB_OUTPUT"
          echo "Packaged chart: ${CHART_FILE}"

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push chart to GHCR
        run: |
          # Push the Helm chart to GHCR
          helm push .build-packages/${{ steps.package.outputs.chart_file }} oci://${REGISTRY}/${{ github.repository_owner }}

      - name: Upload Helm chart to release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          #Upload Helm chart to release assets

          cp .build-packages/${{ steps.package.outputs.chart_file }} chart.tgz
          gh release upload ${{ env.RELEASE_VERSION }} chart.tgz --clobber

      - name: Download previous Helm index
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the previous regular release
          PREVIOUS_RELEASE=$(gh release list --exclude-pre-releases --limit 2 --json tagName --jq '.[1].tagName')

          if [ -z "$PREVIOUS_RELEASE" ]; then
            echo "No previous regular release found!"
            exit 1
          else
            echo "Previous regular release: ${PREVIOUS_RELEASE}"

            # Download the index.yaml from the previous regular release
            gh release download "${PREVIOUS_RELEASE}" --pattern "index.yaml" --output existing-index.yaml
          fi

      - name: Create Helm repository index
        run: |
          # Create a temporary directory for indexing
          mkdir -p temp-charts
          cp .build-packages/*.tgz temp-charts/

          # Generate index for the new chart pointing to GitHub releases
          helm repo index temp-charts --url https://github.com/${{ github.repository }}/releases/download/${{ env.RELEASE_VERSION }}

          # Merge with existing index if it exists and is not empty
          if [ -s existing-index.yaml ]; then
            helm repo index temp-charts --url https://github.com/${{ github.repository }}/releases/download/${{ env.RELEASE_VERSION }} --merge existing-index.yaml
          fi

      - name: Upload Helm index to release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: gh release upload ${{ env.RELEASE_VERSION }} temp-charts/index.yaml --clobber
